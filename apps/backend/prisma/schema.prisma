// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../../../packages/db/generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SportType {
  FOOTBALL
  BASKETBALL
  TENNIS
  BADMINTON
  VOLLEYBALL
  PICKLEBALL
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELED
  COMPLETED
}

enum PaymentProvider {
  STRIPE
}

enum PaymentStatus {
  SUCCESS
  FAILED
  REFUNDED
}

enum AdminStatus {
  ACTIVE
  INACTIVE
}

enum PlayerStatus {
  ACTIVE
  BANNED
}

enum OwnerStatus {
  ACTIVE
  SUSPENDED
}

enum RecurrenceType {
  WEEKLY
  MONTHLY
}

enum RecurringStatus {
  ACTIVE
  PENDING
  CONFIRMED
  CANCELED
  COMPLETED
}

enum ComplexStatus {
  DRAFT
  PENDING
  ACTIVE
  REJECTED
  INACTIVE
}

model Account {
  id                        String          @id @default(uuid()) @db.Uuid
  email                     String          @unique @db.VarChar(50)
  password                  String          @db.Text
  full_name                 String          @db.VarChar(100)
  phone_number              String          @unique @db.VarChar(15)
  avatar                    String?         @db.Text
  email_verified            Boolean         @default(false)
  phone_verified            Boolean         @default(false)
  created_at                DateTime        @default(now()) @db.Timestamptz(0)
  updated_at                DateTime        @updatedAt @db.Timestamptz(0)
  verification_token        String?         @unique @db.Text // Token duy nhất để verify
  verification_expires_at   DateTime?       @db.Timestamptz(0) // Thời gian hết hạn của link
  reset_password_token      String?         @unique @db.Text
  reset_password_expires_at DateTime?       @db.Timestamptz(0)
  social_accounts           SocialAccount[]
  refresh_tokens            RefreshToken[]
  notifications             Notification[]
  admin                     Admin?
  owner                     Owner?
  player                    Player?
}

model Admin {
  id         String      @id @default(uuid()) @db.Uuid
  account_id String      @unique @db.Uuid
  account    Account     @relation(fields: [account_id], references: [id], onDelete: Cascade)
  status     AdminStatus
  created_at DateTime    @default(now()) @db.Timestamptz(0)
  updated_at DateTime    @updatedAt @db.Timestamptz(0)
}

model Owner {
  id                         String      @id @default(uuid()) @db.Uuid
  account_id                 String      @unique @db.Uuid
  account                    Account     @relation(fields: [account_id], references: [id], onDelete: Cascade)
  company_name               String      @db.VarChar(100)
  stripe_account_id          String?     @db.VarChar(100)
  stripe_onboarding_complete Boolean     @default(false)
  status                     OwnerStatus
  complexes                  Complex[]
}

model Player {
  id                String             @id @default(uuid()) @db.Uuid
  account_id        String             @unique @db.Uuid
  account           Account            @relation(fields: [account_id], references: [id], onDelete: Cascade)
  status            PlayerStatus
  bookings          Booking[]
  recurringBookings RecurringBooking[]
}

model RefreshToken {
  id         String  @id @default(uuid()) @db.Uuid
  token      String  @unique @db.Text
  account_id String  @db.Uuid
  account    Account @relation(fields: [account_id], references: [id], onDelete: Cascade)

  revoked    Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamptz(0)
  expires_at DateTime @db.Timestamptz(0)

  @@index([account_id])
}

model SocialAccount {
  id          String  @id @default(uuid()) @db.Uuid
  provider    String  @db.VarChar(50)
  provider_id String  @db.VarChar(100)
  account_id  String  @db.Uuid
  account     Account @relation(fields: [account_id], references: [id], onDelete: Cascade)

  @@unique([provider, provider_id]) // một social account là duy nhất theo (provider, provider_id)
  @@unique([account_id, provider]) // mỗi account chỉ liên kết 1 account cho mỗi provider
  @@index([account_id])
}

model Complex {
  id                String        @id @default(uuid()) @db.Uuid
  owner_id          String        @db.Uuid
  owner             Owner         @relation(fields: [owner_id], references: [id], onDelete: Restrict)
  complex_name      String        @db.VarChar(100)
  complex_address   String        @db.Text
  status            ComplexStatus
  verification_docs Json          @db.Json
  complex_image     String?       @db.Text
  min_price         Int?          @db.Integer // Cached minimum price across all subfields
  max_price         Int?          @db.Integer // Cached maximum price across all subfields
  total_subfields   Int           @default(0) @db.SmallInt // Cached count of active subfields
  sport_types       String[]      @default([]) @db.VarChar(50) // Cached array of available sport types
  created_at        DateTime      @default(now()) @db.Timestamptz(0)
  updated_at        DateTime      @updatedAt @db.Timestamptz(0)
  sub_fields        SubField[]

  @@index([owner_id])
  @@index([min_price]) // For filtering by price range
  @@index([status]) // For filtering active complexes
}

model SubField {
  id                String             @id @default(uuid()) @db.Uuid
  complex_id        String             @db.Uuid
  complex           Complex            @relation(fields: [complex_id], references: [id], onDelete: Restrict)
  sub_field_name    String             @db.VarChar(100)
  capacity          Int                @db.SmallInt
  sub_field_image   String?            @db.Text
  sport_type        SportType
  isDelete          Boolean            @default(false)
  created_at        DateTime           @default(now()) @db.Timestamptz(0)
  updated_at        DateTime           @updatedAt @db.Timestamptz(0)
  recurringBookings RecurringBooking[]
  bookings          Booking[]
  pricing_rules     PricingRule[]

  // Partial unique index: tên sân con là duy nhất trong 1 khu chỉ khi chưa bị xóa
  @@unique([complex_id, sub_field_name, isDelete], map: "SubField_complex_id_sub_field_name_key")
  @@index([complex_id])
}

model PricingRule {
  id           String   @id @default(uuid()) @db.Uuid
  sub_field_id String   @db.Uuid
  sub_field    SubField @relation(fields: [sub_field_id], references: [id], onDelete: Cascade)
  day_of_week  Int      @db.SmallInt
  start_time   DateTime @db.Time(0) // Format: "HH:MM"
  end_time     DateTime @db.Time(0) // Format: "HH:MM"
  base_price   Decimal  @db.Decimal(10, 2)

  @@unique([sub_field_id, day_of_week, start_time, end_time]) // tránh trùng rule y hệt
  @@index([sub_field_id, day_of_week, start_time])
}

model RecurringBooking {
  id                String          @id @default(uuid()) @db.Uuid
  player_id         String          @db.Uuid
  player            Player          @relation(fields: [player_id], references: [id], onDelete: Cascade)
  sub_field_id      String          @db.Uuid
  sub_field         SubField        @relation(fields: [sub_field_id], references: [id], onDelete: Cascade)
  recurrence_type   RecurrenceType
  recurrence_detail Json            @db.Json
  // {
  //   "day_of_week": 2, // 1: T2, 2: T3, ..., 7: CN
  //   "start_time": "19:00",
  //   "end_time": "20:30"
  // }
  start_date        DateTime        @db.Date
  end_date          DateTime        @db.Date
  status            RecurringStatus
  created_at        DateTime        @default(now()) @db.Timestamptz(0)
  bookings          Booking[]

  @@index([player_id])
  @@index([sub_field_id])
}

model Booking {
  id                   String            @id @default(uuid()) @db.Uuid
  start_time           DateTime          @db.Timestamptz(0)
  end_time             DateTime          @db.Timestamptz(0)
  total_price          Decimal           @db.Decimal(10, 2)
  status               BookingStatus
  created_at           DateTime          @default(now()) @db.Timestamptz(0) // thời gian tạo booking
  paid_at              DateTime?         @db.Timestamptz(0) // thời gian thanh toán
  player_id            String            @db.Uuid
  player               Player            @relation(fields: [player_id], references: [id], onDelete: Restrict)
  sub_field_id         String            @db.Uuid
  sub_field            SubField          @relation(fields: [sub_field_id], references: [id], onDelete: Restrict)
  payment_id           String?           @db.Uuid
  payment              Payment?          @relation(fields: [payment_id], references: [id])
  recurring_booking_id String?           @db.Uuid
  recurringBooking     RecurringBooking? @relation(fields: [recurring_booking_id], references: [id])
  expires_at           DateTime          @db.Timestamptz(0)

  @@index([sub_field_id, start_time])
  @@index([player_id, start_time])
}

model Payment {
  id               String          @id @default(uuid()) @db.Uuid
  amount           Decimal         @db.Decimal(10, 2)
  provider         PaymentProvider
  transaction_code String          @unique
  status           PaymentStatus
  bookings         Booking[]
  created_at       DateTime        @default(now()) @db.Timestamptz(0)
}

model Notification {
  id         String   @id @default(uuid()) @db.Uuid
  account_id String   @db.Uuid
  account    Account  @relation(fields: [account_id], references: [id], onDelete: Cascade)
  message    String   @db.Text
  is_read    Boolean  @default(false)
  type       String
  link_to    String?
  created_at DateTime @default(now()) @db.Timestamptz(0)
}
